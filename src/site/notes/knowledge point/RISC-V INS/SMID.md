---
{"dg-publish":true,"permalink":"/knowledge point/RISC-V INS/SMID/","dgPassFrontmatter":true}
---

**这个概念分在这个目录下有些不合适，但我暂时还没想到它应该归类到哪儿**

### 概念
SIMD(**Single Instruction Multiple Data**)即单指令流多数据流，是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。简单来说就是一个指令能够同时处理多个数据。
这种技术不止在CPU中使用，在GPU的ALU单元内，一条指令可以处理多维向量（一般是4D）的数据。比如，有以下shader指令：
```
float4 c = a + b; // a, b都是float4类型
```
对于没有SIMD的处理单元，需要4条指令将4个float数值相加，汇编伪代码如下：
```assembly
ADD c.x, a.x, b.x
ADD c.y, a.y, b.y
ADD c.z, a.z, b.z
ADD c.w, a.w, b.w
```
但有了SIMD技术，只需一条指令即可处理完：
```assembly
SIMD_ADD c, a, b
```
![Pasted image 20240513133047.png](/img/user/knowledge%20point/imgs/Pasted%20image%2020240513133047.png)

### SIMD的好处
虽然很难并行执行代码，但是，当处理诸如图像，几何，机器学习和大量科学计算之类的事情时，对数据的多个元素执行相同的操作相当简单。
换而言之，SIMD为我们提供了一种轻松加快这些计算速度的方法。如果可以只执行一条指令就可以加8个数字，那么基本上可以实现8倍的加速。因此，多年来x86和ARM微处理器堆积在大量SIMD指令上就不足为奇了。
GPU基本上包含执行大量SIMD计算的核心存储区。这就是大大提高了图形性能的原因，也是为什么科学代码越来越多地使用GPU的原因。

### SIMD的问题
对于向量长度确定的SIMD指令集，主要问题是选择正确的向量寄存器大小。虽然因为摩尔定律的存在，向量寄存器的大小可以随着时间的推移而增加，而不会增加CPU芯片的成本，但是对于不同的应用场景而言，合适的向量寄存器大小也在不断变化，例如服务器、科学计算领域的用户需要更宽更大的向量寄存器，而一般消费者则对平均大小的寄存器感到满意。以x86为例，答案是提供一个接一个的ISA，SSE(128位)、AVX(256位)和AVX512(512位)、例如MMX(64 位寄存器)，而为了向前兼容，这种方式带来了很多兼容性的问题。
